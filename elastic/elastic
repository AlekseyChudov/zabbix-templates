#!/usr/bin/python

from __future__ import print_function

import argparse
import json
import inspect
import pprint
import socket
import sys

from elasticsearch import Elasticsearch
from elasticsearch.client.utils import NamespacedClient

__author__ = 'Aleksey Chudov <aleksey.chudov@gmail.com>'
__date__ = '14 Nov 2016'
__version__ = '1.0.1'

USAGE = """usage examples:
    elastic --help

    elastic localhost:9200 /
    elastic localhost:9200 /discovery
    elastic localhost:9200 /discovery/cluster
    elastic localhost:9200 /discovery/nodes
    elastic localhost:9200 /cat
    elastic localhost:9200 /cat/master
    elastic localhost:9200 /cluster
    elastic localhost:9200 /cluster/health
    elastic localhost:9200 /cluster/health/status
    elastic localhost:9200 /cluster/health/status -d
    elastic localhost:9200 /cluster/health/status level=shards -d

    elastic localhost:9200,localhost:9201,localhost:9202 /
"""

ES_DEFAULT_RETRIES = 3
ES_DEFAULT_TIMEOUT = 3


class ES(object):

    ERROR_VALUE = 'ZBX_NOTSUPPORTED'

    @classmethod
    def _discovery_cluster(cls, args, es):
        metric = 'cluster_name'
        cluster_state = es.cluster.state(metric=metric)

        if args.debug:
            debug_name = '{}(metric={})'.format(es.cluster.state, metric)
            debug(debug_name, cluster_state)

        data = []
        if is_node_match(args.params.get('node')):
            data.append({'{#ES_CLUSTER_NAME}': cluster_state['cluster_name']})

        return data

    @classmethod
    def _discovery_nodes(cls, args, es):
        metric = 'process'
        nodes_info = es.nodes.info(metric=metric)

        if args.debug:
            debug_name = '{}(metric={})'.format(es.nodes.info, metric)
            debug(debug_name, nodes_info)

        data = []
        for node_id in nodes_info['nodes'].keys():
            node_name = nodes_info['nodes'][node_id]['name']
            if is_node_match(args.params.get('node'), node_name):
                item = {
                    '{#ES_CLUSTER_NAME}': nodes_info['cluster_name'],
                    '{#ES_NODE_ID}': node_id,
                    '{#ES_NODE_NAME}': node_name
                }
                data.append(item)

        return data

    @classmethod
    def _get_discovery(cls, args, es):
        prefix = '_discovery_'
        discovery_method = cls._get_discovery_method(args.paths, prefix)
        values = []

        if is_discovery_root(args.paths):
            values.extend(get_startswith_strip(cls, is_method, prefix))

        elif discovery_method:
            discovery = {'data': discovery_method(args, es)}
            values.append(json.dumps(discovery, separators=(',', ':')))
        else:
            values.append(cls.ERROR_VALUE)

        return join_string(values)

    @classmethod
    def _get_discovery_method(cls, paths, prefix):
        method = None
        if len(paths) == 2 and hasattr(cls, prefix + paths[1]):
            method = getattr(cls, prefix + paths[1])

        return method

    @classmethod
    def _get_attributes(cls, obj, attributes):
        results = []
        try:
            for attr in attributes:
                if attr == attributes[-1] and is_list(obj):
                    for obj_elem in obj:
                        results.append(obj_elem[attr])
                else:
                    obj = obj[attr]
        except (KeyError, TypeError):
            results.append(cls.ERROR_VALUE)

        if not results:
            if is_dict(obj):
                results.extend(obj.keys())
            elif is_list(obj):
                results.extend(obj)
            else:
                results.append(obj)

        return results

    @classmethod
    def _get_value(cls, args, objects, attributes):
        obj = objects[-1]
        values = []

        if is_es(obj) and not attributes:
            values.append('discovery')
            values.extend(get_public_members(obj, is_client))
            values.extend(get_public_members(obj, is_method))

        elif is_client(obj) and not attributes:
            values.extend(get_public_members(obj, is_method))

        elif is_method(obj):
            result = obj(**args.params)
            if args.debug:
                debug_name = '{}({})'.format(obj, join_params(args.params))
                debug(debug_name, result)

            values.extend(cls._get_attributes(result, attributes))
        else:
            values.append(cls.ERROR_VALUE)

        return join_string(values)

    @classmethod
    def get_result(cls, args):
        es = Elasticsearch(args.nodes, timeout=args.timeout,
                           retry_on_timeout=True, max_retries=args.retries)

        if is_discovery(args.paths):
            result = cls._get_discovery(args, es)
        else:
            objects, attributes = parse_paths(es, args.paths)
            if args.debug:
                debug('objects', objects)
                debug('attributes', attributes)

            result = cls._get_value(args, objects, attributes)

        return result


def debug(name, value):
    print('{}: '.format(name), file=sys.stderr)
    pprint.pprint(value, stream=sys.stderr)


def get_startswith_strip(obj, predicate, prefix):
    names = []
    for name, value in inspect.getmembers(obj, predicate):
        if name.startswith(prefix):
            end_of_prefix = len(prefix)
            names.append(name[end_of_prefix:])

    return names


def get_public_members(obj, predicate):
    names = []
    for name, values in inspect.getmembers(obj, predicate):
        if not name.startswith('_'):
            names.append(name)

    return names


def is_client(obj):
    return isinstance(obj, NamespacedClient)


def is_dict(obj):
    return isinstance(obj, dict)


def is_discovery(paths):
    return len(paths) and paths[0] == 'discovery'


def is_discovery_root(paths):
    return len(paths) == 1


def is_es(obj):
    return isinstance(obj, Elasticsearch)


def is_list(obj):
    return isinstance(obj, list)


def is_method(obj):
    return inspect.ismethod(obj)


def is_node_match(node, name=''):
    match = True
    if node == 'local' and name:
        match = (name == socket.gethostname() or name == socket.getfqdn())
    elif node:
        match = (node == socket.gethostname() or node == socket.getfqdn())

    return match


def join_params(params):
    return ', '.join('{}={}'.format(*item) for item in params.items())


def join_string(iterable, function=None):
    return ' '.join(filter(function, map(str, iterable))).strip()


def split_params(param, sep=None):
    return dict(p.split(sep) for p in param if len(p.split(sep)) == 2)


def split_string(string, sep=None, function=None):
    return filter(function, string.split(sep))


def parse_paths(es, paths):
    attributes = []
    objects = [es]

    for i in range(len(paths)):
        path = paths[i]
        if hasattr(objects[-1], path):
            objects.append(getattr(objects[-1], path))
        else:
            attributes.extend(paths[i:])
            break

    return objects, attributes


def parse_args():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter, epilog=USAGE)

    parser.add_argument('-d', '--debug', action='store_true')
    parser.add_argument('-r', '--retries', default=ES_DEFAULT_RETRIES, type=int)
    parser.add_argument('-t', '--timeout', default=ES_DEFAULT_TIMEOUT, type=int)
    parser.add_argument('node')
    parser.add_argument('path')
    parser.add_argument('param', nargs='*')

    parser.set_defaults(func=ES.get_result)

    args = parser.parse_args()
    args.nodes = split_string(args.node, ',')
    args.paths = split_string(args.path, '/')
    args.params = split_params(args.param, '=')

    if args.debug:
        debug('args', args)

    return args


def main():
    args = parse_args()
    try:
        print(args.func(args))
    except Exception as e:
        if args.debug:
            raise
        print(e)


if __name__ == '__main__':
    main()
